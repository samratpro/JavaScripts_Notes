# Got – Complete TypeScript Techniques

A TypeScript-first, copy-paste-ready reference for making HTTP requests with got. Includes production-tested patterns, retry/timeouts, streaming, proxying, cookie management, caching, and advanced scraper examples.

## Why Got?
- 100% TypeScript support with built-in types
- Promise-based, human-friendly API
- Built-in retry, timeout, redirect, streaming
- Hooks, caching, proxy & cookie support
- Better defaults than many alternatives

## Installation

```bash
npm install got
# Types are built-in
```

## Quick Start (TypeScript)

```ts
import got from 'got';

// Simple GET and parse JSON
const json = await got('https://httpbin.org/json').json();

// GET as text / buffer
const html = await got('https://example.com').text();
const buf = await got('https://example.com/file').buffer();

// POST JSON
await got.post('https://httpbin.org/post', {
  json: { hello: 'world' }
});
```

## Common Options (99% of Use Cases)

```ts
await got(url, {
  timeout: { request: 10000 },  // 10s total timeout
  retry: { limit: 3 },          // retry 3 times
  followRedirect: true,
  throwHttpErrors: false,       // don't throw on 4xx/5xx
  headers: {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
    Accept: 'text/html,application/xhtml+xml',
    'Accept-Language': 'en-US,en;q=0.9'
  }
});
```

## Pro-Level Got Instance (Recommended for Scraping)

Create a reusable client to centralize behavior, hooks and defaults.

```ts
import got from 'got';

const scraper = got.extend({
  timeout: { request: 15000 },
  retry: { limit: 3, methods: ['GET', 'POST'] },
  followRedirect: true,
  headers: {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) Scraper/1.0',
    'Accept-Language': 'en-US,en;q=0.9',
    'Accept-Encoding': 'gzip, deflate, br'
  },
  hooks: {
    beforeRequest: [
      options => {
        console.log(`→ ${options.method} ${options.url}`);
      }
    ],
    afterResponse: [
      response => {
        console.log(`← ${response.statusCode} ${response.url}`);
        return response;
      }
    ]
  }
});
export default scraper;

// Usage
const html = await scraper.get('https://example.com').text();
```

## Proxy Support (TypeScript)

```ts
import { HttpsProxyAgent } from 'https-proxy-agent';
import got from 'got';

const proxy = 'http://user:pass@123.45.67.89:8000';
const agent = new HttpsProxyAgent(proxy);

const res = await got('https://example.com', {
  agent: { https: agent }
});
```

## Random User-Agent + Proxy Rotation

Rotate headers or agents per-request or via a small factory.

```ts
import got from 'got';
import { HttpsProxyAgent } from 'https-proxy-agent';

const userAgents = [
  'Mozilla/5.0 (Windows NT 10.0; Win64; x64)...',
  'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)...'
];
const proxies = ['http://ip1:port', 'http://ip2:port'];

let i = 0;
const client = got.extend({
  hooks: {
    beforeRequest: [
      options => {
        const ua = userAgents[i % userAgents.length];
        const proxy = proxies[i % proxies.length];
        options.headers!['user-agent'] = ua;
        options.agent = { https: new HttpsProxyAgent(proxy) };
        i++;
      }
    ]
  }
});
```

Note: Creating a new agent per-request can be expensive if done at high scale. Reuse agents where possible.

## Streaming (Large files)

```ts
import { pipeline } from 'stream/promises';
import fs from 'fs';
import got from 'got';

await pipeline(
  got.stream('https://huge-file.com/data.zip'),
  fs.createWriteStream('data.zip')
);
```

## JSON Mode with Types

```ts
interface GitHubUser {
  login: string;
  id: number;
  // add fields you need
}

const user = await got('https://api.github.com/users/octocat').json<GitHubUser>();
```

## Error Handling Best Practices

```ts
try {
  const res = await scraper.get('https://example.com');
} catch (err: any) {
  if (err.response?.statusCode === 429) {
    console.warn('Rate limited - backing off...');
    await new Promise(r => setTimeout(r, 5000));
  }
  if (err.code === 'ETIMEDOUT') {
    console.warn('Timeout – maybe switch proxy or increase timeout');
  }
  if (err.code === 'ECONNREFUSED') {
    console.warn('Connection refused – proxy or host unreachable');
  }
  throw err; // rethrow if you can't handle
}
```

## Pagination Helper (TypeScript Generator)

```ts
async function* fetchAllPages<T>(startUrl: string) {
  let nextUrl: string | null = startUrl;
  while (nextUrl) {
    const res = await scraper.get(nextUrl, { responseType: 'json' });
    yield res.body as T;
    const link = res.headers['link'] as string | undefined;
    nextUrl = link?.match(/<([^>]+)>;\s*rel="next"/)?.[1] ?? null;
  }
}
```

## Cookie Management (Session Persistence)

```ts
import got from 'got';
import { CookieJar } from 'tough-cookie';
import { HttpsCookieAgent } from 'http-cookie-agent/http';

const cookieJar = new CookieJar();
const client = got.extend({
  cookieJar,
  agent: {
    https: new HttpsCookieAgent({ cookies: { jar: cookieJar } })
  }
});

// login form example
await client.post('https://example.com/login', {
  form: { username: 'me', password: 'secret' }
});

const profile = await client.get('https://example.com/my-profile').text();
```

Manual cookie setting (sometimes used for bypassing simple bot checks):

```ts
await client.get('https://httpbin.org/cookies/set', {
  searchParams: { session_id: 'abc123', cf_clearance: 'xyz' }
});
```

## Request Caching (Reduce duplicate requests)

```ts
import got from 'got';

const cacheClient = got.extend({
  cache: new Map()
});

// First request hits network
await cacheClient('https://example.com');
// Second request served from cache if TTL and headers allow
await cacheClient('https://example.com');
```

For production, consider a proper cache layer (cacheable-request, keyv, redis adapter).

## Got Cheat Sheet

- got(url) → simple GET
- got.get(url, options) → GET
- got.post(url, { json: {} }) → POST JSON
- .text() → string
- .json<T>() → parsed JSON typed as T
- .buffer() → Buffer
- .stream() → stream.Readable
- got.extend({ ... }) → create reusable client

## Advanced Techniques (Additions)

These advanced patterns expand on the previous sections without changing structure — copy-paste-ready, TypeScript-first.

### HTTP/2 & HTTP/3 considerations
- got supports http2 via http2: true. HTTP/2 can improve performance for many small resources.
- Example:
```ts
const http2Client = got.extend({ http2: true, timeout: { request: 15000 } });
const body = await http2Client.get('https://http2.site').text();
```
- HTTP/3 is not directly supported by Node core yet for all runtimes; use a specialized client or headless browser for HTTP/3-heavy sites.

### Agent reuse, connection pooling & keep-alive
- Reuse Agent instances across requests to avoid excessive sockets:
```ts
import https from 'https';
const keepAliveAgent = new https.Agent({ keepAlive: true, maxSockets: 50 });
const client = got.extend({ agent: { https: keepAliveAgent } });
```
- Reusing agents reduces TLS handshake cost and improves throughput.

### SOCKS proxies / Tor
- Use socks proxy agents for Tor or SOCKS5:
```ts
import { SocksProxyAgent } from 'socks-proxy-agent';
const agent = new SocksProxyAgent('socks5h://127.0.0.1:9050');
await got('https://example.com', { agent: { https: agent }});
```

### Proxy pool with health checks
- Maintain a pool of proxies, periodically health-check them with lightweight HEAD requests. Mark dead proxies and rotate.
- Health-check pseudo:
```ts
async function checkProxy(proxyUrl: string) {
  try {
    const agent = new HttpsProxyAgent(proxyUrl);
    await got.head('https://example.com', { agent, timeout: 5000 });
    return true;
  } catch { return false; }
}
```

### Advanced retry: beforeRetry, jitter, and custom conditions
- Implement exponential backoff with jitter and custom retry conditions:
```ts
const client = got.extend({
  retry: {
    limit: 4,
    calculateDelay: ({attemptCount, error, retryOptions}) => {
      const base = Math.min(1000 * 2 ** (attemptCount - 1), 30_000);
      const jitter = Math.random() * 300;
      if (error?.response?.statusCode === 429) return base + jitter;
      return attemptCount >= retryOptions.limit ? 0 : base + jitter;
    }
  },
  hooks: {
    beforeRetry: [
      (options, error, retryCount) => {
         console.log(`Retry #${retryCount} for ${options.url}: ${error?.message}`);
      }
    ]
  }
});
```

### Idempotency & POST safety
- For POST requests that may be retried, generate an idempotency key and send header X-Idempotency-Key to avoid duplicate side effects on the server (if server supports it).

### AbortController for cancellation
- Cancel long-running requests:
```ts
const controller = new AbortController();
setTimeout(() => controller.abort(), 10000);
try {
  await got('https://slow.example.com', { signal: controller.signal });
} catch (err) {
  if (err.name === 'AbortError') console.log('Request aborted');
}
```

### Streaming parsing (line-by-line / chunk processing)
- Stream a large response and process chunks without buffering whole body:
```ts
import split2 from 'split2';
await pipeline(
  got.stream('https://streaming.example.com/logs'),
  split2(),
  async function* (source) {
    for await (const line of source) {
      // process each line
      yield;
    }
  }
);
```

### Multipart forms / file uploads
- Use form-data or got's body with streams for multipart:
```ts
import fs from 'fs';
await got.post('https://upload', {
  body: fs.createReadStream('file.zip'),
  headers: { 'content-type': 'application/zip' }
});
```

### Advanced caching (keyv + redis adapter)
- Use keyv + redis for a shared cache across instances:
```ts
import Keyv from 'keyv';
import KeyvRedis from '@keyv/redis';
const keyv = new Keyv({ store: new KeyvRedis(process.env.REDIS_URL) });
const cached = got.extend({ cache: keyv });
```

### Rate limiting & concurrency control
- Use Bottleneck or p-queue per-target host to throttle requests:
```ts
import Bottleneck from 'bottleneck';
const limiter = new Bottleneck({ minTime: 200 }); // one request per 200ms
const limitedGet = limiter.wrap((url: string) => got.get(url).text());
await limitedGet('https://example.com');
```

### Circuit breaker pattern
- Implement a circuit breaker (e.g., opossum) around problematic hosts. If error rate is high, pause requests temporarily and avoid wasting resources.

### TLS & fingerprinting considerations
- Keep TLS options (ALPN, ciphers) and SNI intact by using Node's Agent options. Some anti-bot systems fingerprint TLS; to mitigate, use realistic agents/proxies or headless browser approaches.

### Customizing transform / afterResponse
- Use afterResponse hook to transparently handle transient responses (unwrapping HTML wrappers, following meta redirects, or clearing anti-bot pages):
```ts
hooks: {
  afterResponse: [
    (response) => {
      // inspect response.body or status and return a modified response
      return response;
    }
  ]
}
```

### Logging, observability & metrics
- Instrument with request ids, timings, and attach to a tracing system (OpenTelemetry). Add unique IDs in headers and log per-request lifecycle via hooks.

### Security & privacy
- Never log sensitive tokens.
- Rotate credentials and proxies.
- Respect robots.txt and legal constraints.

### Got + Headless Hybrid Pattern
- Use got for static pages and a headless browser (Playwright/Puppeteer) only for JS-heavy flows. Cache browser-rendered HTML so you avoid repeated browser runs.

### Example: Combined advanced pattern (TypeScript)
```ts
import got from 'got';
import Bottleneck from 'bottleneck';
import { HttpsProxyAgent } from 'https-proxy-agent';

const limiter = new Bottleneck({ minTime: 250 });
const agent = new HttpsProxyAgent(process.env.PROXY!);

const client = got.extend({
  timeout: { request: 20000 },
  agent: { https: agent },
  retry: { limit: 3 },
  hooks: {
    beforeRequest: [
      opts => opts.headers!['x-request-id'] = `req-${Date.now()}`
    ]
  }
});

const limitedFetch = limiter.wrap((url: string) => client.get(url).text());
const html = await limitedFetch('https://example.com');
```

## Best Practices
1. Respect robots.txt and terms of service.
2. Add random delays between requests: await delay(1000 + Math.random() * 2000).
3. Use residential proxies for difficult targets.
4. Handle 403/429 with retries and proxy rotation.
5. Avoid scraping personal data (GDPR/CCPA).
6. Set meaningful timeouts.
7. Log requests & responses for debugging.
8. Test selectors in browser console before automating.
9. Cache responses when reasonable.
10. Reuse got instances and network agents to avoid resource churn.

## Anti-Bot Headers (Common Useful Headers)

```ts
const headers = {
  'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
  Accept: 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
  'Accept-Language': 'en-US,en;q=0.5',
  'Accept-Encoding': 'gzip, deflate, br',
  Connection: 'keep-alive',
  'Upgrade-Insecure-Requests': '1'
};
```

Keep header sets consistent with a realistic browser to reduce suspicion.

---
Happy scraping with got + TypeScript!
