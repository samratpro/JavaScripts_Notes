# Playwright TypeScript Examples - Advanced Usage

## Package Installation

Before running these examples, install required dependencies:

```bash
# Core packages
npm install playwright
npm install -D typescript
npm install -D @types/node

# Optional packages used in examples
npm install playwright-extra-plugin-stealth  # For stealth mode

# Install browsers
npx playwright install
```

For real browser control examples, you may also need:
```bash
npm install child_process  # Built-in, no installation needed
```
### **Fix  type module if missing in package.json**
```json
{
  "type": "module",
  "main": "index.js",
}
```

---

## 01. Cookie Management with Chromium/Custom Chrome

### Basic Cookie Saving & Loading Pattern

```typescript
// Install: npm install playwright
import { chromium } from 'playwright';
import type { Browser, BrowserContext } from 'playwright';
import * as fs from 'fs';
import * as path from 'path';

const storageStateFile = path.join(process.cwd(), 'storage_state.json');

function isStorageStateValid(filePath: string): boolean {
  if (fs.existsSync(filePath)) {
    try {
      const content = fs.readFileSync(filePath, 'utf-8').trim();
      if (!content) return false;
      const data = JSON.parse(content);
      return !!data;
    } catch (error) {
      console.error('‚ùå JSON decode error:', error);
      return false;
    }
  }
  return false;
}

const args: string[] = [
  '--disable-blink-features=AutomationControlled',
  '--start-maximized',
  '--disable-infobars',
  '--no-sandbox',
  '--enable-gpu',
  '--use-gl=desktop',
  '--enable-webgl',
  '--enable-accelerated-2d-canvas',
  '--autoplay-policy=no-user-gesture-required',
  '--disable-dev-shm-usage',
  '--disable-extensions',
  '--remote-debugging-port=0',
  '--disable-web-security',
  '--enable-features=WebRTCPeerConnectionWithBlockIceAddresses',
  '--force-webrtc-ip-handling-policy=disable_non_proxied_udp',
];

let browser: Browser | null = null;
let context: BrowserContext | null = null;

async function saveSessionAndExit(): Promise<void> {
  try {
    if (context) {
      console.log('\nüíæ Saving session cookies...');
      await context.storageState({ path: storageStateFile });
      console.log('‚úÖ Cookies saved successfully!');
      console.log(`üìÅ File: ${storageStateFile}`);
      
      // Verify file exists
      if (fs.existsSync(storageStateFile)) {
        const fileSize = fs.statSync(storageStateFile).size;
        console.log(`üìä File size: ${fileSize} bytes`);
      }
    }
  } catch (error) {
    console.error('‚ùå Error saving cookies:', error);
  } finally {
    if (context) await context.close().catch(() => {});
    if (browser) await browser.close().catch(() => {});
    process.exit(0);
  }
}

async function runBrowser(): Promise<void> {
  try {
    browser = await chromium.launch({
      headless: false,
      args: args,
    });

    if (isStorageStateValid(storageStateFile)) {
      console.log('‚úÖ Loading existing session...');
      context = await browser.newContext({
        storageState: storageStateFile,
        viewport: null,
      });
    } else {
      console.log('üìã Creating new session...');
      context = await browser.newContext({ viewport: null });
    }

    const page = await context.newPage();
    await page.goto('https://www.linkedin.com/');

    console.log('\nüåê Browser is running.');
    console.log('üìå Do your login and work. Close browser when done.\n');

    // Monitor page events to detect when browser closes
    page.on('close', async () => {
      console.log('üìç Page closed event detected');
      await saveSessionAndExit();
    });

    // Setup process signal handlers
    process.on('SIGINT', async () => {
      console.log('\n‚èπÔ∏è Interrupt signal received');
      await saveSessionAndExit();
    });

    process.on('SIGTERM', async () => {
      console.log('\n‚èπÔ∏è Terminate signal received');
      await saveSessionAndExit();
    });

    // Monitor for all pages being closed
    browser.on('disconnected', async () => {
      console.log('üìç Browser disconnected event detected');
      await saveSessionAndExit();
    });

    // Periodic check every 5 seconds if browser is still alive
    const checkInterval = setInterval(async () => {
      try {
        if (browser && !browser.isConnected?.()) {
          console.log('üìç Browser connection lost');
          clearInterval(checkInterval);
          await saveSessionAndExit();
        }
      } catch (error) {
        clearInterval(checkInterval);
        await saveSessionAndExit();
      }
    }, 5000);

    // Keep the script running
    await new Promise(() => {});

  } catch (error) {
    console.error('‚ùå Fatal error:', error);
    await saveSessionAndExit();
  }
}

// Run the browser
runBrowser().catch(async (error) => {
  console.error('‚ùå Uncaught error:', error);
  await saveSessionAndExit();
});
```

### 01.1 Gmail Login Example

```typescript
// Install: npm install playwright
import { chromium } from 'playwright';
import * as path from 'path';

const indeedStorageLoginFile = path.join(process.cwd(), 'indeed_storage_login.json');

function isStorageStateValid(filePath: string): boolean {
  if (require('fs').existsSync(filePath)) {
    try {
      const content = require('fs').readFileSync(filePath, 'utf-8').trim();
      return content.length > 0 && !!JSON.parse(content);
    } catch (error) {
      return false;
    }
  }
  return false;
}

async function loginWithGoogle() {
  if (!isStorageStateValid(indeedStorageLoginFile)) {
    const browser = await chromium.launch({
      headless: false,
      args: ['--disable-blink-features=AutomationControlled'],
    });

    const context = await browser.newContext({ viewport: null });
    const page = await context.newPage();

    await page.goto(
      'https://secure.indeed.com/auth?hl=en_US&co=US&continue=https%3A%2F%2Fwww.indeed.com'
    );

    // Click Google login button
    await page.click('//button[@id="login-google-button"]');

    // Wait for new tab and bring it to front
    const newPagePromise = context.waitForEvent('page');
    const newPage = await newPagePromise;
    await newPage.bringToFront();

    console.log('Please log in using Google and then press Enter:');
    await new Promise(resolve => process.stdin.once('data', resolve));

    // Save session
    await context.storageState({ path: indeedStorageLoginFile });
    console.log('‚úÖ Session saved.');
    await browser.close();
  }
}

loginWithGoogle().catch(console.error);
```

---

## 02. Work with Real Browser (Chrome with Remote Debugging)

```typescript
// Install: npm install playwright child_process
import { chromium } from 'playwright';
import { spawn } from 'child_process';
import * as path from 'path';
import * as fs from 'fs';

let chromeProcess: any = null;

function findChromePath(): string {
  const possiblePaths = [
    'C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe',
    'C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe',
    path.join(process.env.LOCALAPPDATA || '', 'Google\\Chrome\\Application\\chrome.exe'),
    'C:\\Program Files\\Microsoft\\Edge\\Application\\msedge.exe',
    'C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe',
    path.join(process.env.LOCALAPPDATA || '', 'Microsoft\\Edge\\Application\\msedge.exe'),
  ];

  for (const chromePath of possiblePaths) {
    if (fs.existsSync(chromePath)) {
      console.log(`‚úÖ Found Chrome at: ${chromePath}`);
      return chromePath;
    }
  }

  console.log('‚ùå Chrome executable not found');
  console.log('Example: C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe');

  // Prompt user for path
  const readline = require('readline');
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  return new Promise((resolve, reject) => {
    rl.question('Enter Chrome path: ', (userPath: string) => {
      rl.close();
      userPath = userPath.trim().replace(/"/g, '');

      if (!fs.existsSync(userPath)) {
        console.log(`‚ùå File not found at: ${userPath}`);
        reject(new Error('Chrome path not found'));
      } else if (userPath.toLowerCase().endsWith('chrome.exe')) {
        console.log(`‚úÖ Chrome path verified: ${userPath}`);
        resolve(userPath);
      } else {
        reject(new Error('Path should point to chrome.exe'));
      }
    });
  });
}

async function startChrome(): Promise<string> {
  const chromePath = await findChromePath();
  const userDataDir = 'C:\\ChromeProfile';

  chromeProcess = spawn(chromePath, [
    '--remote-debugging-port=9222',
    `--user-data-dir=${userDataDir}`,
    '--disable-webrtc=false',
    '--no-first-run',
    '--no-default-browser-check',
  ]);

  await new Promise(resolve => setTimeout(resolve, 2000));
  console.log('‚úÖ Chrome started with remote debugging.');
  
  return chromePath;
}

async function controlChrome(): Promise<void> {
  const CDP_URL = 'http://127.0.0.1:9222';

  const browser = await chromium.connectOverCDP(CDP_URL);

  const contexts = browser.contexts;
  let page;

  if (contexts.length === 0) {
    console.log('No existing tabs found. Creating a new tab.');
    page = await browser.newPage();
  } else {
    page = contexts[0].pages()[0];
  }

  await page.goto('https://www.facebook.com');

  console.log('Page Title:', page.url());
  console.log('Press Enter to close browser');
  await new Promise(resolve => process.stdin.once('data', resolve));

  await browser.close();
}

async function closeChrome(): Promise<void> {
  if (chromeProcess) {
    try {
      chromeProcess.kill();
      console.log('‚úÖ Chrome process closed.');
    } catch (error) {
      console.error('‚ùå Error closing Chrome:', error);
    }
  } else {
    console.log('No Chrome process to close.');
  }
}

// Run the functions
(async () => {
  try {
    await startChrome();
    await controlChrome();
  } catch (error) {
    console.error('Error:', error);
  } finally {
    await closeChrome();
  }
})();
```

---

## 03. Cookie Use with Real Chrome Browser

```typescript
// Install: npm install playwright child_process
import { chromium } from 'playwright';
import { spawn } from 'child_process';
import * as fs from 'fs';
import * as path from 'path';

const storageStateFile = path.join(process.cwd(), 'storage_state.json');
let chromeProcess: any = null;

function isStorageStateValid(filePath: string): boolean {
  if (fs.existsSync(filePath)) {
    try {
      const content = fs.readFileSync(filePath, 'utf-8').trim();
      if (!content) return false;
      const data = JSON.parse(content);
      return !!data;
    } catch (error) {
      console.error('JSON decode error:', error);
      return false;
    }
  }
  return false;
}

function findChromePath(): string {
  const possiblePaths = [
    'C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe',
    'C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe',
    path.join(process.env.LOCALAPPDATA || '', 'Google\\Chrome\\Application\\chrome.exe'),
    'C:\\Program Files\\Microsoft\\Edge\\Application\\msedge.exe',
  ];

  for (const chromePath of possiblePaths) {
    if (fs.existsSync(chromePath)) {
      console.log(`‚úÖ Found Chrome at: ${chromePath}`);
      return chromePath;
    }
  }

  throw new Error('Chrome not found');
}

async function startChrome(): Promise<void> {
  const chromePath = findChromePath();
  const userDataDir = 'C:\\ChromeProfile';

  chromeProcess = spawn(chromePath, [
    '--remote-debugging-port=9222',
    `--user-data-dir=${userDataDir}`,
    '--disable-webrtc=false',
    '--no-first-run',
    '--no-default-browser-check',
  ]);

  await new Promise(resolve => setTimeout(resolve, 2000));
  console.log('‚úÖ Chrome started with remote debugging.');
}

async function controlChrome(): Promise<void> {
  const CDP_URL = 'http://127.0.0.1:9222';

  const browser = await chromium.connectOverCDP(CDP_URL);
  const contexts = browser.contexts;

  let page;
  if (contexts.length === 0) {
    console.log('No existing tabs found. Creating a new tab.');
    page = await browser.newPage();
  } else {
    page = contexts[0].pages()[0];
  }

  await page.goto('https://www.pinterest.com/');
  
  console.log('Press Enter to save the session and close the browser...');
  await new Promise(resolve => process.stdin.once('data', resolve));

  await page.context().storageState({ path: storageStateFile });
  console.log('‚úÖ Session saved to storage_state.json.');
  
  await browser.close();
}

async function reuseSession(): Promise<void> {
  if (isStorageStateValid(storageStateFile)) {
    const CDP_URL = 'http://127.0.0.1:9222';
    
    const browser = await chromium.connectOverCDP(CDP_URL);
    const contexts = browser.contexts;

    let page;
    if (contexts.length === 0) {
      console.log('No existing tabs found. Creating a new tab.');
      const context = await browser.newContext({
        storageState: storageStateFile,
      });
      page = await context.newPage();
    } else {
      page = contexts[0].pages()[0];
    }

    await page.goto('https://www.pinterest.com/pin-creation-tool/');
    console.log('‚úÖ Navigated to Pinterest using saved session. Add logic here...');

    console.log('Press Enter to close browser');
    await new Promise(resolve => process.stdin.once('data', resolve));

    await browser.close();
  } else {
    console.log('Invalid or missing storage state file.');
  }
}

async function closeChrome(): Promise<void> {
  if (chromeProcess) {
    try {
      chromeProcess.kill();
      console.log('‚úÖ Chrome process closed.');
    } catch (error) {
      console.error('Error closing Chrome:', error);
    }
  }
}

// Run the script
(async () => {
  try {
    await startChrome();
    
    if (isStorageStateValid(storageStateFile)) {
      await reuseSession();
    } else {
      await controlChrome();
    }
  } catch (error) {
    console.error('Error:', error);
  } finally {
    await closeChrome();
  }
})();
```

---

## 04. Fixed: 3-Tab Async Scraping

```typescript
// Install: npm install playwright
import { chromium } from 'playwright';

interface ScrapedData {
  url: string;
  h1: string | null;
  title: string;
}

const dataStoreList: ScrapedData[] = [];

const errorList = [
  'https://github.com/samratpro',
  'https://www.fiverr.com/',
  'https://surelockkey.com/',
  'https://surelockkey.com/404',
  'https://surelockkey.com/blog',
];

async function fetchUrlWithPlaywright(
  page: any,
  url: string,
  dataStoreList: ScrapedData[]
): Promise<void> {
  try {
    await page.goto(url);
    
    const h1Element = await page.query_selector('h1');
    const h1 = h1Element ? await page.text_content('h1') : null;
    const title = await page.title();
    
    dataStoreList.push({ url, h1, title });
    console.log(`Fetched URL: ${url}, h1: ${h1}, title: ${title}`);
  } catch (error) {
    console.error(`Error fetching ${url}:`, error);
  }
}

async function main(): Promise<void> {
  console.log('Starting 3-tab async scraping...');
  
  const { chromium } = await import('playwright');
  const browser = await chromium.launch({ headless: false });
  const context = await browser.newContext();

  // Create 2 pages
  const pages = [
    await context.newPage(),
    await context.newPage(),
  ];

  // Visit URLs in batches of 2
  const batchSize = 2;
  for (let i = 0; i < errorList.length; i += batchSize) {
    const batch = errorList.slice(i, i + batchSize);
    const tasks = batch.map((url, index) =>
      fetchUrlWithPlaywright(pages[index], url, dataStoreList)
    );
    
    await Promise.all(tasks);
  }

  await browser.close();

  // Output the results
  console.log('\nüìä Data store list:');
  dataStoreList.forEach(item => console.log(item));
}

main().catch(console.error);
```

---

## 05. Limit Concurrency: 3-Tab Async with Semaphore

```typescript
// Install: npm install playwright
import { chromium } from 'playwright';

const semaphore = { value: 0, max: 2 };

async function acquireSemaphore(): Promise<void> {
  while (semaphore.value >= semaphore.max) {
    await new Promise(resolve => setTimeout(resolve, 10));
  }
  semaphore.value++;
}

function releaseSemaphore(): void {
  semaphore.value--;
}

async function visitLink(
  context: any,
  link: string
): Promise<void> {
  await acquireSemaphore();
  
  try {
    const page = await context.newPage();
    await page.goto(link);
    console.log(`‚úÖ Visited: ${link}`);
    await page.close();
  } catch (error) {
    console.error(`Error visiting ${link}:`, error);
  } finally {
    releaseSemaphore();
  }
}

async function main(links: string[]): Promise<void> {
  const { chromium } = await import('playwright');
  const browser = await chromium.launch({ headless: false });
  const context = await browser.newContext();

  const tasks = links.map(link => visitLink(context, link));

  await Promise.all(tasks);

  await context.close();
  await browser.close();
}

const linkList = [
  'https://github.com/samratpro',
  'https://www.fiverr.com/',
  'https://surelockkey.com/',
  'https://surelockkey.com/404',
  'https://surelockkey.com/blog',
];

main(linkList).catch(console.error);
```

---

## 06. Amazon Product Scraping with Multi-Tab

```typescript
// Install: npm install playwright
import { chromium } from 'playwright';

interface ProductData {
  title: string;
  description: string;
  dimensions: string;
  reviews: string;
}

interface ScrapedProduct extends ProductData {
  url: string;
}

async function scrapeProduct(page: any, link: string): Promise<ProductData | null> {
  try {
    await page.goto(link);
    await page.waitForLoadState('load');

    const title = await page.locator("//span[@id='productTitle']").textContent();
    const description = await page
      .locator("//div[@id='feature-bullets']")
      .textContent();

    const dimensionsEle = page.locator('#productDetails_techSpec_section_1');
    const dimensions = (await dimensionsEle.count()) > 0
      ? await dimensionsEle.textContent()
      : '';

    const reviewEle = page.locator(
      "(//div[@data-hook='review-collapsed'])[1]//span"
    );
    const review = (await reviewEle.count()) > 0
      ? await reviewEle.textContent()
      : '';

    return {
      title: title?.trim() || '',
      description: description?.trim() || '',
      dimensions: dimensions?.trim() || '',
      reviews: review || '',
    };
  } catch (error) {
    console.error(`Error scraping ${link}:`, error);
    return null;
  }
}

async function scrapeAmazon(
  keyword: string,
  numTabs: number = 3
): Promise<ScrapedProduct[]> {
  const dataList: ScrapedProduct[] = [];

  const { chromium } = await import('playwright');
  const browser = await chromium.launch({ headless: false });
  const context = await browser.newContext({
    storageState: 'amazon_data/cookie.json',
    viewport: null,
  });

  // Initial page for search
  const searchPage = await context.newPage();
  const searchUrl = `https://www.amazon.com/s?k=${keyword.replace(/ /g, '+')}`;
  await searchPage.goto(searchUrl);
  await new Promise(resolve => setTimeout(resolve, 1000));

  // Get product links
  const productElements = await searchPage.locator(
    "(((//div[@data-component-type='s-search-result'])//span[@data-component-type='s-product-image'])//a)"
  ).all();

  const links: string[] = [];
  for (const element of productElements.slice(0, 10)) {
    try {
      const href = await element.getAttribute('href');
      if (href) {
        links.push(`https://www.amazon.com${href}`);
      }
    } catch {
      // Skip failed elements
    }
  }

  await searchPage.close();

  // Create multiple pages
  const pages = [];
  for (let i = 0; i < numTabs; i++) {
    pages.push(await context.newPage());
  }

  // Scrape in batches
  for (let i = 0; i < links.length; i += numTabs) {
    const batchLinks = links.slice(i, i + numTabs);
    const batchTasks = batchLinks.map((link, index) =>
      scrapeProduct(pages[index % numTabs], link)
    );

    const results = await Promise.all(batchTasks);
    results.forEach((result, index) => {
      if (result) {
        dataList.push({
          url: batchLinks[index],
          ...result,
        });
      }
    });
  }

  // Cleanup
  for (const page of pages) {
    await page.close();
  }
  await browser.close();

  return dataList;
}

// Run the script
(async () => {
  const results = await scrapeAmazon('laptop stand');
  console.log('\nüì¶ Scraped Products:');
  results.forEach(item => console.log(item));
})().catch(console.error);
```

---

## 07. Work with Custom Browser Arguments

```typescript
// Install: npm install playwright
import { chromium } from 'playwright';
import * as path from 'path';
import * as fs from 'fs';

const storageStateFile = path.join(process.cwd(), 'storage_state.json');

const args = [
  '--disable-blink-features=AutomationControlled',
  '--start-maximized',
  '--disable-infobars',
  '--no-sandbox',
  '--enable-gpu',
  '--use-gl=desktop',
  '--enable-webgl',
  '--enable-accelerated-2d-canvas',
  '--autoplay-policy=no-user-gesture-required',
  '--disable-dev-shm-usage',
  '--disable-extensions',
  '--remote-debugging-port=0',
  '--disable-web-security',
  '--enable-features=WebRTCPeerConnectionWithBlockIceAddresses',
  '--force-webrtc-ip-handling-policy=disable_non_proxied_udp',
];

function isStorageStateValid(filePath: string): boolean {
  if (fs.existsSync(filePath)) {
    try {
      const content = fs.readFileSync(filePath, 'utf-8').trim();
      if (!content) return false;
      return !!JSON.parse(content);
    } catch {
      return false;
    }
  }
  return false;
}

async function main(): Promise<void> {
  const chromePath = 'chrome-win/chrome.exe';

  // First run: Save session
  const browser1 = await chromium.launch({
    executablePath: chromePath,
    headless: false,
    args,
  });

  let context;
  if (isStorageStateValid(storageStateFile)) {
    context = await browser1.newContext({
      storageState: storageStateFile,
      viewport: null,
    });
  } else {
    context = await browser1.newContext({ viewport: null });
  }

  const page = await context.newPage();
  await page.goto('https://www.pinterest.com/');

  console.log('Please log in and then press Enter to close the browser...');
  await new Promise(resolve => process.stdin.once('data', resolve));

  await context.storageState({ path: storageStateFile });
  console.log('‚úÖ Session saved.');
  await browser1.close();

  // Second run: Reuse session
  if (isStorageStateValid(storageStateFile)) {
    const browser2 = await chromium.launch({
      executablePath: chromePath,
      headless: false,
      args,
    });

    const context2 = await browser2.newContext({
      storageState: storageStateFile,
    });

    const page2 = await context2.newPage();
    await page2.goto('https://www.pinterest.com/');
    
    console.log('‚úÖ Loaded with saved session');
    await new Promise(resolve => setTimeout(resolve, 5000));
    
    await browser2.close();
  } else {
    console.log('‚ùå Invalid or missing storage state file.');
  }
}

main().catch(console.error);
```

---

## TypeScript Best Practices for These Examples

### Type Definitions

```typescript
// Install: npm install -D typescript @types/node
// Define reusable types
interface BrowserConfig {
  headless?: boolean;
  args?: string[];
  executablePath?: string;
  proxy?: {
    server: string;
    username?: string;
    password?: string;
  };
}

interface ScrapingResult {
  success: boolean;
  data?: any;
  error?: string;
}

// Use strict typing
async function launchBrowserWithConfig(
  config: BrowserConfig
): Promise<any> {
  const { chromium } = await import('playwright');
  return chromium.launch(config);
}
```

### Error Handling Pattern

```typescript
async function safeExecute<T>(
  fn: () => Promise<T>,
  errorMessage: string
): Promise<T | null> {
  try {
    return await fn();
  } catch (error) {
    console.error(`${errorMessage}:`, error);
    return null;
  }
}
```

### Resource Management

```typescript
class PlaywrightManager {
  private browser: any;
  private context: any;

  async initialize(config: BrowserConfig): Promise<void> {
    const { chromium } = await import('playwright');
    this.browser = await chromium.launch(config);
    this.context = await this.browser.newContext();
  }

  async cleanup(): Promise<void> {
    await this.context?.close();
    await this.browser?.close();
  }

  getContext(): any {
    return this.context;
  }
}
```

---

**Last Updated:** 2025
**Language:** TypeScript
**Converted from:** Python Playwright Examples
